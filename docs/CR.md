# Code Review

- src/app/mod.rs:4121 — `handle_plugin_command` is ~1.1k lines of nested command handling in a single match. The monolith mixes text edits, overlays, status updates, and background process handling, making it very hard to reason about side effects or enforce invariants (e.g., when to append to event logs). Splitting into per-command helpers or a dispatch table would make the plugin surface safer to evolve.
- src/app/mod.rs:3284 — `process_async_messages` spans ~680 lines and handles every async event (diagnostics, completions, hover, references, rename, etc.) inline. The size/branching make it easy to miss required UI updates or error handling for a new variant; consider breaking it into dedicated handlers per message type or delegating to modules.
- src/view/ui/split_rendering.rs:1135 and src/view/ui/ui/split_rendering.rs:1135 — two copies of a ~750-line `render_view_lines` with near-identical logic. Keeping dual copies of the core rendering loop is a maintenance hazard (bug fixes must be applied twice and risk divergence); consolidate into a single implementation with parameters for the few behavioral differences.
- src/app/render.rs:5 — top-level `render` runs ~450 lines covering layout calculation, plugin hook firing, file explorer rendering, and status/prompt UI. The amount of responsibility in one function hurts readability and testing; factoring into helpers (layout, plugin hook prep, explorer rendering, status/prompt rendering) would make regressions easier to spot.
- src/services/lsp/async_handler.rs:1543 — `run` is ~490 lines long, combining RPC dispatch, stdout reader task setup, request bookkeeping, and response handling in one async function. This centralizes too many concerns; splitting request send/receive handling and server-driven callbacks would reduce complexity and make failure paths clearer.
- src/services/lsp/async_handler.rs:395/433 — serialization of request/notification params uses `expect`, which will panic the LSP task on any serde failure (including bad data from plugins or the server). These should return errors and surface diagnostics instead of taking down the client runtime.
- src/services/lsp/client.rs:265/317 — same `expect` on serde serialization in `send_request`/`send_notification`, so a bad param payload will panic the blocking LSP client; bubble errors rather than aborting.
- src/main.rs:75 — `File::create(\"/tmp/editor.log\").expect(\"Failed to create log file\")` will panic on startup if `/tmp` is unavailable or unwritable (disk full, permissions), taking down the editor before showing the UI. Prefer returning an error or falling back to stderr logging to avoid aborting at launch.
- src/state.rs:223 — `apply` is ~330 lines of event handling with many side effects (markers, cursors, overlays, viewport sync) in a single match. The size and coupling make it risky to extend; consider extracting per-event helpers to keep invariants (cursor/marker updates, highlighting invalidation) localized.
- src/input/keybindings.rs:376 — `Action::from_str` is a ~260-line string-to-enum match. A data-driven table would reduce boilerplate and avoid missing new actions when added to the enum.
- src/input/commands.rs:89 — `get_all_commands` is a ~540-line literal list in one function. This is brittle to maintain (hard to diff/review additions) and couples command metadata to code; consider a data table or config-driven source with tests for completeness.
- src/primitives/highlighter.rs:78 — `highlight_config` is ~450 lines of repetitive per-language setup; moving to a data table (language -> queries/config) would reduce duplication and make it harder to forget highlight names when adding languages.
- src/services/plugins/runtime.rs:3299 and src/services/plugins/thread.rs:738 — two separate ~240-line `hook_args_to_json` implementations build JSON for hooks. Duplication means any new HookArgs variant or bug fix must be changed in both; extract a shared helper to keep the protocol consistent.
- src/app/mod.rs:826 — `open_file` is ~300 lines combining path canonicalization, buffer reuse, binary detection, buffer creation, metadata setup, and LSP bootstrapping. The breadth and nesting make it easy to regress (e.g., mixing buffer lifecycle with LSP requests); splitting into focused helpers would improve safety.
- src/config.rs:566 — `default_menus` is a 420-line literal definition. Consider moving menu data to structured config or a table to make changes easier to diff/test and to avoid bloating code with data.
- src/view/viewport.rs:521 — `ensure_visible` runs ~230 lines of layout math and clamping in one method; breaking into smaller helpers (e.g., horizontal/vertical logic, scroll computations) would make correctness checks and future changes safer.
- src/input/keybindings.rs:1196 — `format_action` spans ~200 lines mirroring `from_str`; another sign a data-driven action registry would reduce duplication and risk of drift.
- src/primitives/highlighter.rs:530 — `highlight_color` is a 150+ line chain of style cases; converting to data (token -> color face) would reduce branching and help ensure new scopes get covered.
- src/primitives/ansi.rs:135 — `parse_sgr_params` is a 150+ line parser built as one function; consider splitting handling for color vs modifier codes to simplify reasoning and reduce risk of missing cases.
- src/view/ui/view_pipeline.rs:134 — `next` is a 160+ line iterator step that handles multiple line types and wrapping; decomposing per-case helpers would make it easier to verify wrapping and newline behaviors.
- src/model/buffer.rs:575 — `get_text_range_mut` is a 160+ line method with intertwined chunk handling, file streaming, and cache management. The dense control flow increases the risk of off-by-one or range bugs; extract helpers per buffer variant (loaded vs unloaded) and centralize bounds checks.
- src/services/plugins/runtime.rs:1861/1967/2066/2143/2159/etc. — repeated `pending_responses.lock().unwrap()` (and other mutex `unwrap()`s) in ops will panic if the mutex is poisoned by a plugin panic. These should handle poisoning and return an error to the plugin rather than crashing the runtime.
- src/view/ui/file_explorer.rs:148 — renderer calls `view.tree().get_node(node_id).expect("Node should exist")`. A desynced tree (e.g., after FS errors or refresh races) will panic the UI; prefer graceful fallback or placeholder row.
- src/view/file_tree/tree.rs:138 — `expand_node` uses `self.get_node(id).unwrap()` while doing async FS reads. If the node was removed between calls, this panics instead of returning an IO error; return a proper error for missing nodes to avoid crashing the explorer.
- src/view/ui/status_bar.rs:149 — `render_status` pulls cursor info with ad-hoc line iteration and cached line numbers in a long method; consider extracting helpers for cursor position and diagnostics summary to reduce the ~200-line render method complexity.
- src/input/actions.rs:1400+ — large match arms with repeated collect-and-apply patterns for deletion/transposition. Consider helper routines for common selection/range collection to reduce duplication and the risk of inconsistent behavior across actions.
- src/view/ui/ui/menu.rs:655/780/815/834 — duplicate menu module under `ui/ui` with the same `unwrap()`-heavy parsing/tests as `view/ui/menu.rs`. Keeping two copies invites divergence and doubles the panic surface for malformed menu configs; consolidate to one implementation and harden parsing.
- src/model/cursor.rs:220 — `primary()`/`primary_mut()` use `expect("Primary cursor should always exist")`. If a bug ever removes the primary cursor (e.g., during multi-cursor deletion), the editor will panic. Prefer returning an error or recreating a primary cursor to keep the UI alive.
- src/model/marker_tree.rs:494/509/512/517/etc. — AVL rotations and queries use unchecked `unwrap()` on child pointers. Any tree corruption (e.g., from earlier logic bugs) will panic. Consider defensive checks or debug assertions gated for release builds to avoid crashing the editor.
- src/view/split.rs:162 — `ensure_layout` returns `self.layout.as_ref().unwrap()`. If callers forget to call `ensure_layout` before `get_layout` usage, rendering will panic. Consider returning `Option<&Layout>` or asserting via a Result to make misuse harder in production.
- src/view/ui/split_rendering.rs:1642/1838 and src/view/ui/ui/split_rendering.rs:1482/1688 — rendering paths `unwrap()` optional highlight colors/positions when overlays and syntax spans overlap. If the lookups ever return `None` (e.g., missing semantic span), the renderer will panic; handle `None` with defaults to keep the UI resilient.
- src/view/prompt.rs:974 — `selected_text().unwrap()` in selection paths; production prompt operations should avoid panics when no selection exists (e.g., racey UI updates or plugin-driven prompt changes).
- src/input/buffer_mode.rs: ModeRegistry and BufferMode rely on string names without validation; missing mode references during inheritance or resolve silently stop traversal, which can mask misconfigurations. Consider explicit errors/logging for unknown parent/mode to aid debugging.
- src/view/viewport.rs:895 — `ensure_cursors_visible` unwraps min/max cursor positions; if called with an empty cursor list (due to upstream logic bugs), it will panic. Guard against empty input to keep scrolling resilient.
- src/view/ui/suggestions.rs:80/87 — width calculations use `.max().unwrap_or(0)` on suggestion lists; if any suggestion text/keybinding is extremely wide, width computation and rendering alignment are packed into the main render function. Consider extracting layout calculation and handling unreasonably wide strings to avoid overflow/panic in rendering math.
- src/services/signal_handler.rs:23/104 — global backtrace storage uses `Mutex::lock().unwrap()`; any poisoning (e.g., panic during signal handling) will panic again. Signal handlers should avoid unwraps and degrade gracefully to prevent double panics during shutdown.
- src/services/async_bridge.rs:300/324/329/356/... — multiple `unwrap()`s on channel send/recv in the bridge; if the channel is closed (e.g., runtime shutdown), the bridge will panic instead of allowing a clean exit. Return errors and let the main loop terminate gracefully.
- src/services/process_limits.rs:405/406/459/476/496/503 — heavy use of `unwrap()` around serialization and system resource reads; a failure to read system memory or serialize limits will panic instead of bubbling a configuration error. Prefer error propagation.
- src/view/viewport.rs:895 — already noted for empty cursor panic; also consider clamping logic to avoid underflow when `line_span >= visible_count`.
- src/services/plugins/api.rs & event_hooks/process: widespread `RwLock::unwrap()` and channel `unwrap()`s. A poisoned lock or closed channel will panic plugins and potentially the editor. Replace with error paths that surface to the plugin caller or log-and-drop to keep the host stable.
- src/view/ui/ui/status_bar.rs and src/view/ui/ui/file_explorer.rs — duplicate implementations of core UI components; appears unused (no references in module tree). Delete or consolidate to avoid divergence and stray panic surface.
- src/input/command_registry.rs — plugin command registration/history uses `RwLock::unwrap()` in production paths; a poisoned lock (plugin panic) will crash the editor. Handle lock errors and surface failures to plugins.
- src/input/actions.rs:68 — block selection reads `cursor.block_anchor.unwrap()` when in block mode; if state enters block mode without an anchor, movement will panic. Guard against None to keep editing stable.
- src/services/plugins/process.rs:132/166/195/226 — plugin process bridge uses `recv().unwrap()`; closed channels during shutdown will panic the host. Treat channel closure as cancellation to allow clean teardown.
- src/view/ui/ui (entire directory) — duplicated UI stack alongside `src/view/ui` but not referenced in the module tree (dead code). Remove to avoid confusion and duplicated maintenance.
- src/services/plugins/process.rs — blocking `recv()` loops have no timeout/backoff; a misbehaving plugin can hang the thread. Consider async or timeout-aware handling to avoid host hangs.
- src/app/mod.rs:71 — re-export of `BufferId` “for backward compatibility” keeps legacy API surface alive; consider deprecating/removing to reduce drift and encourage callers to use the canonical type path.
- src/services/async_bridge.rs — uses unbounded std::sync::mpsc channels with no backpressure or eviction; a burst of async messages (e.g., LSP floods) can grow memory unbounded. Consider bounded channels or dropping strategies plus explicit error propagation on lock/channel failure.
- src/services/plugins/event_hooks.rs — `apply_event_with_hooks` runs plugin hooks inline and ignores hook panics/poisoned locks. A plugin hook panic will crash core edits; consider isolating hook execution (catch_unwind/log) to keep the editor stable.
- src/input/multi_cursor.rs — add-cursor helpers duplicate similar line/column/iterator logic three times; extracting shared helpers would reduce subtle drift between above/below/next-match behaviors.
- src/view/ui/tabs.rs — `render_for_split` packs tab width calculation, scroll computation, and rendering into one long function; consider splitting into layout calculation and render steps to improve readability and reduce bugs in scroll math.
- src/services/process_limits.rs — applies limits via cgroups/setrlimit with many unwraps noted; also lacks clear fallback/reporting when limits can’t be applied (e.g., non-Linux or missing cgroup perms). Return actionable errors so callers can decide to continue without limits.

## Test Code
- src/view/ui/menu.rs:655/776/811/830 — menu parsing/rendering tests use `unwrap()`; production parsing should handle malformed plugin menu contributions gracefully.
- src/services/fs/slow.rs — tests use `TempDir::new().unwrap()`/`read_dir().await` unwraps; ensure production slow backend surfaces IO errors cleanly.
- src/view/popup.rs — selection tests `unwrap()` the selected item; production popup handling should guard empty lists.
